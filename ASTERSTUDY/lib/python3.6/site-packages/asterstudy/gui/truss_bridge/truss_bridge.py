import sys
import os
import shutil
import time
import pvsimple as pvs
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QDialog,QFrame
from PyQt5.QtWidgets import QApplication,QFileDialog
from PyQt5 import uic
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import QDir
from PyQt5.Qt import *
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow
from PyQt5 import Qt as Q

from .truss_bridge_ui import Ui_Workspace
from ...post import (ResultFile, PlotWindow,
            ColorRep, WarpRep, ModesRep, BaseRep,
            pvcontrol, show_min_max, selection_probe, selection_plot,
            get_active_selection, get_pv_mem_use, dbg_print,
            RESULTS_PV_LAYOUT_NAME, RESULTS_PV_VIEW_NAME)

from .. import ActionType, clipboard_text
from ...common import (MeshElemType, MeshGroupType, common_filters, connect,
#                       debug_mode, get_cmd_groups, get_cmd_mesh, get_file_name,
#                       重新定义 get_cmd_groups, get_cmd_mesh
                       debug_mode, get_file_name,get_medfile_meshes,get_medfile_groups,get_medfile_groups_by_type,
                       is_child, is_medfile, is_reference, is_subclass,
                       is_valid_group_name, load_icon, translate)
from ..salomegui_utils import *


class Main(QWidget):
    meshFileChanged = Q.pyqtSignal(str, str, float, bool)
    meshGroupCheck = Q.pyqtSignal(str, str, str, int)
    meshGroupCheckColor = Q.pyqtSignal(str, str, str, int,list)
    meshGroupUnCheck = Q.pyqtSignal(str, str, str, int)
    #beamsectionChanged = Q.pyqtSignal(int)
    def __init__(self,input):
        super(Main,self).__init__()
        self.pv_view = None
        self.res = self.ren_view = self.default_file_root = None
        self.meshlist_all=[]
        self.minmax6 = None
        #self.astergui = astergui
        self.previous = {}
        #self.curr_dir = os.popen('echo `pwd`').read()[0:-1]
        self.curr_dir = '/home/annidiot/salome/SALOME-9.4.0-UB18.04-SRC/BINARIES-UB18.04/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/truss_bridge'
        self.curr_dir_2 = '/amd_share/online1/install/truss_bridge/SALOME-9.4.0-CO7-SRC/asterstudy/gui'
        self.work_dir = '/home/annidiot/salome/SALOME-9.4.0-UB18.04-SRC/BINARIES-UB18.04/ASTERSTUDY/lib/python3.6/site-packages/asterstudy/gui/truss_bridge'
        #print(self.work_dir)
        #self.astergui = astergui
        self.meshview = input
        self.ui = Ui_Workspace()
        self.ui.setupUI(self)
        ## 启用外部进程
        self.process = QtCore.QProcess(self)
        #self.process1 = QtCore.QProcess(self)
        self.process2 = QtCore.QProcess(self)
        #self.process.readyRead.connect(self.dataReady)
        #self.process2.readyRead.connect(self.dataReady)
        #self.init_paraview()
        #self.change_element_pro() # 自动写入属性
        self.file_name = ''
        self.nom_med = ''
        # 确认按钮
        self.ui.pushButton_ok.clicked.connect(self.cal_spacing)
        connect(self.meshFileChanged, self.meshview.displayMEDFileName)
        # 还原按钮
        self.ui.pushButton_reset.clicked.connect(self.reset)
        # 梁属性赋予高亮显示
        #self.ui.tabWidget_2.currentChanged.connect(self.cal_spacing)
        self.ui.tabWidget_2.currentChanged['int'].connect(self.highlight_beams)
        #self.beamsectionChanged.connect(self.highlight_beams)
        connect(self.meshGroupCheckColor, self.meshview.displayMeshGroupcolor)
        connect(self.meshGroupUnCheck, self.meshview.undisplayMeshGroup)
        # 单元属性应用按钮 
        self.ui.pushButton_beam.clicked.connect(self.change_element_pro)
        self.ui.apply.clicked.connect(self.change_element_pro)
        # 提交计算
        self.ui.pushButton_4.clicked.connect(self.submit)
        self.ui.pushButton_break.clicked.connect(self.show_result)
        #self.ui.tabWidget.currentChanged['int'].connect(self.main_tab_change)
    def startmesh(self,fname):
        self.meshlist_all = [fname]
        print('self.meshlist_all:',self.meshlist_all)
        #self._updateMeshList()
        self.file_name, self.nom_med = self.get_cmd_mesh(self.meshlist_all[0])
        #self.fname, self.nom_med = self.get_cmd_mesh(self.meshlist_all[0])
        print('file_name:',self.file_name)
        print('nom_med:',type(self.nom_med))
        self.meshFileChanged.emit(self.file_name, self.nom_med, 1.0, True)
        #self.meshview.displayAllGroups(file_name, nom_med)
        self.highlight_beams()


    def highlight_beams(self):
        """"""
        beam_list=['road','main_beams','lateral_beams','top_beams','bottom_beams']
        rgb_list = [[1,0,0.498039],[0,0.333333,1],[0,1,0.333333],[1,1,0],[1,1,0]]
        index = self.ui.tabWidget_2.currentIndex()
        print('index:',index)
        var = beam_list[index]
        rgb = rgb_list[index]
        #if index !=0:
         #   self.beamsectionChanged.emit()
        grtype = MeshGroupType.GElement
        all_groups = get_medfile_groups(self.file_name, None, grtype)
        print('all_groups:',all_groups)
        for g in all_groups:
            self.meshGroupUnCheck.emit(self.file_name,
                                        self.nom_med,
                                        g,
                                        MeshGroupType.GElement)

        self.meshGroupCheckColor.emit(self.file_name,
                                        self.nom_med,
                                        var,
                                        MeshGroupType.GElement,
                                        rgb)

         #if typ in ('groups_ma',) else MeshGroupType.GNode
        
        #for var in all_groups:
        #self.meshGroupUnCheck.emit(file_name,
         #                           nom_med,
          #                          var,
           #                         self._meshGroupType(),)

    def _meshGroupType(self):
        """
        Get the type of the mesh group

        Returns:
            str: Mesh group type (see `MeshGroupType`).
        """
        #mgtype = -1
        #mgtype = MeshGroupType.GElement
        if self.qiehuan == 1:
            mgtype = MeshGroupType.GNode
        else:
            mgtype = MeshGroupType.GElement
        #kw_def = self.keyword().definition
        #typ = kw_def.get('typ')
        #if isinstance(typ, (tuple, list)):
        #    typ = typ[0] if typ else None
        #if is_subclass(typ, CATA.package('DataStructure').grma):
        #    mgtype = MeshGroupType.GElement
        #elif is_subclass(typ, CATA.package('DataStructure').grno):
        #    mgtype = MeshGroupType.GNode
        return mgtype

    def _updateMeshList(self):
        """
        Updates the mesh list in the combobox
        针对Tanksimulator固体(流体TODO)前处理进行了重写 Daizijian 2019/11/26
        """
        #mlist_cur = avail_meshes(parameterPanel(self).pendingStorage())
        #mlist_cmd = avail_meshes(parameterPanel(self).pendingCommandStorage())
        #mlist_cmd = [m for m in mlist_cmd if m not in mlist_cur]
        #meshlist = mlist_cur + mlist_cmd
        #meshlist.reverse()
        # self._loade

        meshlist=self.meshlist_all
        #self.setMeshList(meshlist)
        msg = ""
        if len(meshlist) >= 1:
            #msg = translate("ParameterPanel", "More than one mesh found")
            #msg = "当前已存储了"+str(len(meshlist))+"个网格"
            msg = "当前上传数"+str(len(meshlist))
        elif not meshlist:
            #msg = translate("ParameterPanel", "No mesh found")
            msg = "当前没有网格"
        #self.setMessage(msg)
        self._meshActivated()

    def _meshActivated(self):
        """
        Updates the mesh groups in checkable list.
        Invoked after mesh changing in mesh combobox.
        """
        meshcmd=self.meshlist_all[0]        
        print('meshcmd', meshcmd)
        print('get_medfile_meshes(meshcmd):',get_medfile_meshes(meshcmd))
        groups = {}
        if meshcmd is not None:
            group_type = self._meshGroupType()
            file_name, nom_med = self.get_cmd_mesh(meshcmd)
            if is_medfile(file_name) or is_reference(file_name):
                self.meshFileChanged.emit(file_name, nom_med, 0.1, False)
                self.minmax6 = self.meshview.getBounding6(file_name,nom_med)
                print('self.minmax6',self.minmax6)

            groups = self.get_cmd_groups(file_name,group_type)
            print('groups:',groups)
        self.meshChanged.emit()

    def _meshGroupType(self):
        """
        Get the type of the mesh group

        Returns:
            str: Mesh group type (see `MeshGroupType`).
        """
        #mgtype = -1
        #mgtype = MeshGroupType.GElement
        if self.qiehuan == 1:
            mgtype = MeshGroupType.GNode
        else:
            mgtype = MeshGroupType.GElement
        return mgtype

    def get_cmd_groups(self,meshcmd, group_type): #重写，顶掉原来的定义   
        #pass
        #定义是 def get_medfile_groups(mesh_file, mesh_name, group_type):
        #return get_medfile_groups(meshcmd, get_medfile_meshes(meshcmd)[0], group_type)
        #return get_medfile_groups(meshcmd, get_medfile_meshes(meshcmd), group_type)
        groups={}
        elem_types = MeshElemType.elem_types(group_type)
        file_name = meshcmd
        nom_med = get_medfile_meshes(meshcmd)[0]
        for elem_type in elem_types:
            elem_groups = get_medfile_groups_by_type(file_name, nom_med,
                                                        elem_type, True)
            groups[elem_type] = elem_groups
        return groups

    def get_cmd_mesh(self,meshcmd):   #重写，顶掉原来的定义   
        # print("get_medfile_meshes返回内容为：",get_medfile_meshes(meshcmd))
        if len(get_medfile_meshes(meshcmd))>1:
            return meshcmd, get_medfile_meshes(meshcmd)[0] # 例如。example.med 取为 example
        elif len(get_medfile_meshes(meshcmd))==1:
            return meshcmd, get_medfile_meshes(meshcmd)[0]

    def change_bridge(self,fdir):
        data = ''
        with open(fdir, 'r+') as f:
            for line in f.readlines():
                if(line.find('width') == 0):
                    line = 'width = %s' % (str(self.width1)) + '\n'
                if(line.find('height') == 0):
                    line = 'height = %s' % (str(self.height1)) + '\n'
                if(line.find('length') == 0):
                    line = 'length = %s' % (str(self.length)) + '\n'
                if(line.find('sections') == 0):
                    line = 'sections = %s' % (str(self.sections)) + '\n'
                data += line
        with open(fdir, 'r+') as f:
            f.writelines(data)

    def check_iseven(self,num):
        s=str(float(num)).split('.')
        if float(s[1])==0:
            print('整数')
            if (int(num) % 2 == 0):
                return True
            else:
                QtWidgets.QMessageBox.information(self, '错误', '节点数必须是偶数!')
                return False
        else :
            print('小数')
            QtWidgets.QMessageBox.information(self, '错误', '节点数必须是偶数!')
            return False

    def cal_spacing(self):
        self.width1 = self.ui.width_lineEdit.text()
        self.length = self.ui.length_lineEdit.text()
        self.height1 = self.ui.height_lineEdit.text()
        self.sections = self.ui.sections_lineEdit.text()
        self.spacing = self.ui.spacing_lineEdit.text() 
        parameters=[self.width1,self.length,self.height1,self.sections]
        for i in parameters:
            print('i:',i)
            self.check_parameter_isnum(i)
        #self.check_iseven(self.sections)
        self.width1 = float('%.2f' % float(self.ui.width_lineEdit.text()))
        self.length = float('%.2f' % float(self.ui.length_lineEdit.text()))
        self.height1 = float('%.2f' % float(self.ui.height_lineEdit.text()))
        self.sections = int(self.ui.sections_lineEdit.text())
        self.spacing = float('%.2f' % float((self.length/self.sections)))
        self.ui.spacing_lineEdit.setText(str(self.spacing))

        parameters=[self.width1,self.height1,self.length,self.sections,self.spacing]

        fname = 'Mesh' #网格文件
        for i in parameters:
            fname = fname + '_' + str(i)
        fname = fname + '.med'
        self.fname = fname
        script_name = 'create_geo_mesh_new.py' #参数化脚本
        fdir = os.path.join(self.work_dir,fname)
        self.fdir_curr = os.path.join(self.curr_dir,fname)
        script_dir = os.path.join(self.work_dir,script_name)
        script_dir_curr = os.path.join(self.curr_dir,script_name)
        self.change_bridge(script_dir)
        time.sleep(0.25)
        try:
            if(self.check_iseven(self.sections)):
                exec(open(script_dir,"rb").read())
                self.process.start('echo 运行参数化建模脚本中')
        except:
            print("脚本错误!")
            self.process.start('echo 脚本错误！')
        #exec(open('/amd_share/online1/install/truss_bridge/script/create_geo_mesh.py').read())
        #self.show_mesh_1(fdir_curr)
        self.startmesh(self.fdir_curr)

    def reset(self):
        self.ui.width_lineEdit.setText('8')
        self.ui.length_lineEdit.setText('40')
        self.ui.height_lineEdit.setText('5')
        self.ui.sections_lineEdit.setText('8')
        self.ui.spacing_lineEdit.setText('5')
        self.cal_spacing()

    def show_mesh_1(self,fdir):
        '''
            显示网格
        '''
        #boundary_file = self.workingdirectory + '/constant/polyMesh/boundary'
        try:
            if self.currentdisplay:
                current_display = pvs.GetActiveSource()
                pvs.Delete(current_display)
                print('delete ok')
                self.process.start('echo 清除当前显示')
                self.process.waitForFinished()
        except Exception as e:
            print(e)
        try:
            self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, False)
            self.static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, False)
            self.process.start('echo 清除图例')
        except:
            self.process.start('echo 无前置图例...')
            self.process.waitForFinished()
        finally:
            self.process.start('echo 开始显示网格...')
            self.process.waitForFinished()
            #self.show_mesh_display_list(boundary_file)
            self.res = pvs.MEDReader(FileName=fdir)
            self.ren_view = pvs.GetRenderView()
            self.foamDisplay =pvs.Show(self.res, self.ren_view)
            #self.foamDisplay.SetRepresentationType('Surface With Edges')
            self.currentdisplay = self.foamDisplay
            # The following two lines insure that the view is refreshed
            #self.pv_splitter.setVisible(False)
            #self.pv_splitter.setVisible(True)
            self.process.start('echo 网格已显示')
            self.process.waitForFinished()

    def create_static_comm(self,material1,material2,element,curr_dir,pres):
        #file = work_dir + '/static.comm'
        fname = 'static.comm'
        file = os.path.join(curr_dir,fname)
        print('file:',file)
        data = ''
        i = 1
        with open(file,'r+') as f:
            for line in f.readlines():
                if(line.find('steel') == 0):
                    #line = 'width = %s' % (str(self.width1)) + '\n'
                    line = 'steel = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material1[0],material1[1],material1[2])  + '\n'
                if(line.find('concrete') == 0):
                    line = 'concrete = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material2[0],material2[1],material2[2])  + '\n'
                '''print(i,len(line))
                if(line.find('CARA',4) == 0):
                    print('ok')'''
                if i == 23:
                    line = '    COQUE=_F(EPAIS=%s, GROUP_MA=(\'road\', )),' % (element[0]) + '\n'
                if i == 30:
                    line = '            VALE=(%s, )' % (element[1]) + '\n'
                if i == 35:
                    line = '            VALE=(%s, )' % (element[2]) + '\n'
                if i == 40:
                    line = '            VALE=(%s, )' % (element[3]) + '\n'
                if i == 45:
                    line = '            VALE=(%s, )' % (element[4]) + '\n'
                if i == 67:
                    line = '    PRES_REP=_F(GROUP_MA=(\'road\', ), PRES=%s)' % (pres) + '\n'
                i+=1
                data += line
        f.close
        #print(data)
        with open(file,'r+') as f:
            f.writelines(data)
        f.close

    def create_modes_comm(self,material1,material2,element,curr_dir,fre):
        fname = 'modes.comm'
        file = os.path.join(curr_dir,fname)
        print('file:',file)
        data = ''
        i = 1
        with open(file,'r+') as f:
            for line in f.readlines():
                if(line.find('steel') == 0):
                    #line = 'width = %s' % (str(self.width1)) + '\n'
                    line = 'steel = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material1[0],material1[1],material1[2])  + '\n'
                if(line.find('concrete') == 0):
                    line = 'concrete = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material2[0],material2[1],material2[2])  + '\n'

                if i == 18:
                    line = '    COQUE=_F(EPAIS=%s, GROUP_MA=(\'road\', )),' % (element[0]) + '\n'
                if i == 25:
                    line = '            VALE=(%s, )' % (element[1]) + '\n'
                if i == 30:
                    line = '            VALE=(%s, )' % (element[2]) + '\n'
                if i == 35:
                    line = '            VALE=(%s, )' % (element[3]) + '\n'
                if i == 40:
                    line = '            VALE=(%s, )' % (element[4]) + '\n'
                if i == 78:
                    line = '    CALC_FREQ=_F(NMAX_FREQ=%s),' % (fre) + '\n'

                i+=1
                data += line
        f.close
        with open(file,'r+') as f:
            f.writelines(data)
        f.close

    def change_element_pro(self):
        #from .create_static_comm import create_static_comm
        #fname = 'static.comm' #网格文件
        #fdir_curr = os.path.join(self.curr_dir,fname)
        element0 = self.ui.tab0_H_value.text()
        element1 = self.ui.tab1_H_value.text()
        element2 = self.ui.tab2_H_value.text()
        element3 = self.ui.tab3_H_value.text()
        element4 = self.ui.tab4_H_value.text()
        self.element = [element0,element1,element2,element3,element4]

        material11 = self.ui.modulus_value_beams.text()
        material12 = self.ui.poisson_value_beams.text()
        material13 = self.ui.rho_value_beams.text()
        self.material1 = [material11,material12,material13]

        material21 = self.ui.modulus_value_road.text()
        material22 = self.ui.poisson_value_road.text()
        material23 = self.ui.rho_value_road.text()
        self.material2 = [material21,material22,material23]
        for i in self.element + self.material1 + self.material2:
            self.check_parameter_isnum(i)
        try:
            self.create_static_comm(self.material1,self.material2,self.element,self.curr_dir,'1e5')
            self.create_modes_comm(self.material1,self.material2,self.element,self.curr_dir,'10')
            #material1=[2e11,0.3,7850]
            #material2=[2.5e10,0.2,2500]
            #element = [0.1,0.2,0.3,0.4,0.5]
            print('curr_dir:',self.curr_dir_2)
            #self.create_static_comm(material1,material2,element,self.curr_dir_2)
            self.process.start('echo 写入comm文件中')

        except:
            self.process.start('echo 写入comm文件失败')
        
    def submit(self):
        if self.ui.modes_button.isChecked():
            self.fre,ok = QtWidgets.QInputDialog.getText(self,'设置所需模态阶数','请输入阶数：')
            print('set fre = ',self.fre)
            while ok and self.check_parameter_isnum(self.fre) and self.check_parameter_isint(self.fre):
                self.create_modes_comm(self.material1,self.material2,self.element,self.curr_dir,self.fre)
                self.disable_some_buttons()
                self.ui.pushButton_4.setEnabled(False)
                #cmd = '/amd_share/online1/install/code_aster_14.6/14.6/bin/as_run '
                cmd = 'sh '
                cmd += self.curr_dir
                cmd += '/submit_2.sh'
                print('cmd_modes:',cmd)
                try:
                    self.process2.start('echo 提交计算')
                    QApplication.processEvents()
                    self.process.start(cmd)
                    #self.process.waitForFinished()
                    QtWidgets.QMessageBox.information(self, '提示', '已提交计算，请稍等!')
                    self.ui.pushButton_4.setEnabled(False)
                    time.sleep(8)
                    self.ui.pushButton_break.setEnabled(True)
                    self.enable_some_buttons()
                    ok = 0
                except:
                    self.process2.start('echo 提交计算失败') 
                    ok = 0           
        else:
            self.pres,ok = QtWidgets.QInputDialog.getText(self,'设置压力','请输入压力/Pa：')
            #cmd = '/amd_share/online1/install/code_aster_14.6/14.6/bin/as_run '
            while ok and self.check_parameter_isnum(self.pres):
                self.disable_some_buttons()
                self.ui.pushButton_4.setEnabled(False)
                self.create_static_comm(self.material1,self.material2,self.element,self.curr_dir,self.pres)    
                cmd = 'sh '
                cmd += self.curr_dir
                cmd += '/submit.sh'
                print('cmd:',cmd)
                try:
                    self.process2.start('echo 提交计算')
                    QApplication.processEvents()
                    self.process.start(cmd)
                    #self.process.waitForFinished()
                    QtWidgets.QMessageBox.information(self, '提示', '已提交计算，请稍等!')
                    self.ui.pushButton_4.setEnabled(False)
                    time.sleep(8)
                    self.ui.pushButton_break.setEnabled(True)
                    self.enable_some_buttons()
                    ok = 0
                except:
                    self.process2.start('echo 提交计算失败')
                    ok = 0
    
    def check_parameter_isnum(self,num):
        try:
            num = float(num)
            s=str(num).split('.')
            if float(s[1])==0:
                print('整数')
                return True
            else :
                print('小数')
                return True
        except:
            print("输入的不是数字!")
            QtWidgets.QMessageBox.information(self, '错误', '请输入数字!')
            return False

    def check_parameter_isint(self,num):
        num = float(num)
        s=str(num).split('.')
        if float(s[1])==0:
            print('整数')
            return True
        else :
            print('小数')
            QtWidgets.QMessageBox.information(self, '错误', '请输入整数!')
            return False       

    def show_modes_result(self):
        #choice = self.fre[0]
        choice_list = self.fre_all
        #QInputDialog.getItem(self, "select input dialog", '语言列表', items, 0, False)
        self.fre_show, ok = QtWidgets.QInputDialog.getItem(self, "select", '阶数', choice_list, 0, False)
        index_id = choice_list.index(self.fre_show)
        print('index_id:',index_id)
        if ok:
            try:
                if self.currentdisplay:
                    current_display = pvs.GetActiveSource()
                    pvs.Delete(current_display)
                    print('delete ok')
                    self.process.start('echo 清除当前显示')
                    self.process.waitForFinished()
                    
            except Exception as e:
                print('show_modes_result error!')
            try:
                self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, False)
                self.static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, False)
                self.process.start('echo 清除图例')
            except:
                self.process.start('echo 无前置图例...')
                self.process.waitForFinished()
            finally:
                fname = 'study_modes.rmed'
                fdir = os.path.join(self.curr_dir,fname)
                self.process.start('echo 开始显示模态分析结果...')
                self.process.waitForFinished()
                self.modes_resrmed = pvs.MEDReader(FileName=fdir)
                animationScene1 = pvs.GetAnimationScene()
                self.modes_resrmed.GenerateVectors = 1
                self.modes_resrmed.ActivateMode = 1
                renderView1 = pvs.GetActiveViewOrCreate('RenderView')
                modes_resrmedDisplay = pvs.Show(self.modes_resrmed, renderView1)
                modes_resrmedDisplay.Representation = 'Surface'
                renderView1.ResetCamera()
                materialLibrary1 = pvs.GetMaterialLibrary()
                animationScene1.UpdateAnimationUsingDataTimeSteps()
                renderView1.Update()

                pvs.Hide(self.modes_resrmed, renderView1)
                self.warpByVector2 = pvs.WarpByVector(Input=self.modes_resrmed)
                self.warpByVector2.ScaleFactor = 3.0
                pvs.SetActiveSource(self.warpByVector2)
                self.warpByVector2Display = pvs.Show(self.warpByVector2, renderView1)
                renderView1.Update()
                self.warpByVector2Display.Representation = 'Surface'
                self.warpByVector2.Vectors = ['POINTS', 'unnamed0DEPL [%s] - %s_Vector' %(index_id,self.fre_show[0:7])]
                pvs.ColorBy(self.warpByVector2Display, ('POINTS', 'unnamed0DEPL [%s] - %s' %(index_id,self.fre_show[0:7]), 'Magnitude'))
                self.warpByVector2Display.RescaleTransferFunctionToDataRange(True, False)
                self.warpByVector2Display.SetScalarBarVisibility(renderView1, False)
                renderView1.Update()
                self.currentdisplay = self.warpByVector2
                # The following two lines insure that the view is refreshed
                self.pv_splitter.setVisible(False)
                self.pv_splitter.setVisible(True)
                self.process.start('echo 网格已显示')
                self.process.waitForFinished()
                self.ui.pushButton_4.setEnabled(True)
        
    def read_fre(self):
        file = self.curr_dir + '/modes.mess'
        num = int(self.fre)
        print('num:',num)
        data = ''
        i = 1
        id_modal = 0
        with open(file,'r+') as f:
            for line in f.readlines():
                if(line.find('     Calcul modal') == 0):
                    #line = 'width = %s' % (str(self.width1)) + '\n'
                    print('modal:',i)
                    id_modal = i
                if i >= (id_modal + 4) and i <= (id_modal + 4 + num -1) and id_modal:
                    data +=line
                i+=1
        f.close
        '''try:
            with open(file,'r+') as f:
                for line in f.readlines():
                    if(line.find('     Calcul modal') == 0):
                        #line = 'width = %s' % (str(self.width1)) + '\n'
                        print('modal:',i)
                        id_modal = i
                    if i >= (id_modal + 4) and i <= (id_modal + 4 + num -1) and id_modal:
                        data +=line
                    i+=1
            f.close
        except:
            print('error! Not find frequency result!')
                #data += line'''
        
        print('id_modal:',id_modal)
        print(data.split())
        fre_data = data.split()
        self.fre_all = []
        for i in range(1,len(fre_data),3):
            #print(fre_data[i])
            self.fre_all.append(fre_data[i])
        print('fre:',self.fre_all)
        self.fre_num = []
        for i in self.fre_all:
            j = i[0:7]
            self.fre_num.append(j)
        print('fre_num:',self.fre_num)

    def select_modes(self):
        #choice = self.fre[0]
        choice_list = self.fre_all
        #QInputDialog.getItem(self, "select input dialog", '语言列表', items, 0, False)
        self.fre_show, ok = QtWidgets.QInputDialog.getItem(self, "select", '阶数', choice_list, 0, False)

    def show_result(self):
        if self.ui.modes_button.isChecked():
            try:
                self.read_fre() # 读取模态结果
            except:
                QtWidgets.QMessageBox.information(self, '提示', '您还没有计算模态!')
            time.sleep(0.5)
            self.show_modes_result()
        else:
            self.show_static_result()

    def show_static_result(self):
        choice_list = ['位移','应力']
        self.res_show, ok = QtWidgets.QInputDialog.getItem(self, "select", '结果类型', choice_list, 0, False)
        try:
            if self.currentdisplay:
                current_display = pvs.GetActiveSource()
                pvs.Delete(current_display)
                print('delete ok')
                self.process.start('echo 清除当前显示')
                self.process.waitForFinished()
        except Exception as e:
                print(e)
        if self.res_show == '位移' and ok:
            fname = 'static_res.rmed'
            fdir = os.path.join(self.curr_dir,fname)
            self.process.start('echo 开始显示静力学结果...')
            self.process.waitForFinished()
            self.static_resrmed = pvs.MEDReader(FileName=fdir)
            self.static_resrmed.AllArrays = ['TS0/mesh/ComSup0/reslin__DEPL@@][@@P1']
            self.static_resrmed.GenerateVectors = 1
            self.renderView1 = pvs.GetActiveViewOrCreate('RenderView')
            static_resrmedDisplay = pvs.Show(self.static_resrmed, self.renderView1)
            static_resrmedDisplay.Representation = 'Surface'
            self.renderView1.ResetCamera()
            materialLibrary1 = pvs.GetMaterialLibrary()
            self.renderView1.Update()
            # set scalar coloring
            pvs.ColorBy(static_resrmedDisplay, ('POINTS', 'reslin__DEPL_Vector', 'Magnitude'))
            # rescale color and/or opacity maps used to include current data range
            static_resrmedDisplay.RescaleTransferFunctionToDataRange(True, False)
            # show color bar/color legend
            static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, True)
            # get color transfer function/color map for 'reslin__DEPL_Vector'
            reslin__DEPL_VectorLUT = pvs.GetColorTransferFunction('reslin__DEPL_Vector')
            # get opacity transfer function/opacity map for 'reslin__DEPL_Vector'
            reslin__DEPL_VectorPWF = pvs.GetOpacityTransferFunction('reslin__DEPL_Vector')
            # create a new 'Warp By Vector'
            self.warpByVector1 = pvs.WarpByVector(Input=self.static_resrmed)
            # set active source
            pvs.SetActiveSource(self.warpByVector1)
            # show data in view
            self.warpByVector1Display = pvs.Show(self.warpByVector1, self.renderView1)
            # trace defaults for the display properties.
            self.warpByVector1Display.Representation = 'Surface'
            # show color bar/color legend
            self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, True)
            # show data in view
            self.warpByVector1Display = pvs.Show(self.warpByVector1, self.renderView1)
            # hide data in view
            pvs.Hide(self.static_resrmed, self.renderView1)
            # show color bar/color legend
            self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, True)
            # update the view to ensure updated data information
            self.renderView1.Update()
            self.currentdisplay = self.warpByVector1
            # The following two lines insure that the view is refreshed
            self.pv_splitter.setVisible(False)
            self.pv_splitter.setVisible(True)
            self.process.start('echo 网格已显示')
            self.process.waitForFinished()
            self.ui.pushButton_4.setEnabled(True)
        if self.res_show == '应力' and ok:
            fname = 'static_res.rmed'
            fdir = os.path.join(self.curr_dir,fname)
            self.process.start('echo 开始显示静力学结果...')
            self.process.waitForFinished()
            self.static_resrmed = pvs.MEDReader(FileName=fdir)
            self.renderView1 = pvs.GetActiveViewOrCreate('RenderView')
            self.static_resrmedDisplay = pvs.Show(self.static_resrmed, self.renderView1)
            self.static_resrmedDisplay.Representation = 'Surface'
            pvs.ColorBy(self.static_resrmedDisplay, ('POINTS', 'reslin__EFGE_NOEU', 'Magnitude'))
            self.static_resrmedDisplay.RescaleTransferFunctionToDataRange(True, False)
            self.static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, True)
            self.renderView1.Update()
            self.currentdisplay = self.warpByVector1
            # The following two lines insure that the view is refreshed
            self.pv_splitter.setVisible(False)
            self.pv_splitter.setVisible(True)
            self.process.start('echo 网格已显示')
            self.process.waitForFinished()
            self.ui.pushButton_4.setEnabled(True)

    def init_paraview(self, full_load_pv=True):
        """
        Initializes, if necessary, paraview and creates a dedicated pvsimple
        view in the results tab.
        """
        from ..salomegui import (get_salome_pyqt, get_salome_gui)

        if not self.pv_view:
            import time
            #dbg_print(">> Initializing PV view for the main tab...")
            start = time.time()
            self.views = get_salome_pyqt().findViews('ParaView')
            self.pv_view = self.views[-1]
            get_salome_pyqt().activateViewManagerAndView(self.pv_view)
            paraview = self.update_pv_layout_view()
            end = time.time()
            #dbg_print("  Finished in %d seconds..." % int(end - start))

            self._finalize_pv_widget()
        else:
            self.update_pv_layout_view()
            self._finalize_pv_widget()

        if self.current:
            self.redraw()

    def _finalize_pv_widget(self):
        """
        References toolbuttons (for interactive selection) and updates the
        overlay widget if needed
        """
        if self.pv_widget:
            if not self.toolbuttons:
                self._add_toolbuttons()
            if not self.pv_overlay:
                self._add_overlay()

    def _add_toolbuttons(self):
        """
        Shortcut for referencing the toolbuttons that may need to be
        automatically activated for point and cell selections

        requires : self.pv_widget
        """
        self.toolbuttons = {'Interactive Select Cells On': None,
                            'Interactive Select Points On': None,
                            'Select Points On (d)': None,
                            'Select Cells On (s)': None,
                            }
        to_find = list(self.toolbuttons.keys())

        for tbutt in self.pv_widget.findChildren(QtWidgets.QToolButton)[::-1]:
            if not to_find:
                break
            for tooltip in to_find:
                if tooltip in tbutt.toolTip():
                    self.toolbuttons[tooltip] = tbutt
                    to_find.remove(tooltip)
                    break

    def update_pv_layout_view(self, full_update=True):
        """
        Updates or creates a new PV layout and view for AsterStudy
        post processing in the Results tab
        """
        import pvsimple as pvs
        from ..salomegui import get_salome_pyqt

        pv_layout = pvs.GetLayoutByName(RESULTS_PV_LAYOUT_NAME)
        if not pv_layout:
            pv_layout = pvs.CreateLayout(name=RESULTS_PV_LAYOUT_NAME)

            
        self.views = pvs.GetViewsInLayout(pv_layout)
        if not self.views:
            pvs.SetActiveView(None)
            self.ren_view = pvs.CreateRenderView(guiName=RESULTS_PV_VIEW_NAME)

            self.ren_view.UseGradientBackground = 1
            pv_layout.AssignView(0, self.ren_view)

        self.pv_layout = pvs.GetLayoutByName("Layout #1")

        self.pv_widget = get_salome_pyqt().getViewWidget(self.pv_view)
        self.pv_widget.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                    QtWidgets.QSizePolicy.Expanding)

        self.pv_splitter.addWidget(self.pv_widget)

        self.pv_splitter.setVisible(False)
        self.pv_splitter.setVisible(True)

        pvs.Render()

        self.pv_widget_children = [self.pv_widget]
        self.pv_widget_children += self.pv_widget.findChildren(QtWidgets.QWidget)

        to_ignore = []
        if self.pv_overlay:
            to_ignore = [self.pv_overlay] + \
                self.pv_overlay.findChildren(QtWidgets.QWidget)

        for child in self.pv_widget_children:
            if not child in to_ignore:
                child.installEventFilter(self)